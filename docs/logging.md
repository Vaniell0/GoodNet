# Система логирования (Logger)

Модуль `Logger` предоставляет потокобезопасную, цветную и гибкую систему логирования для проекта GoodNet. Он построен на базе библиотеки `{fmt}`, что обеспечивает высокую производительность и удобный синтаксис форматирования строк.

## Основные возможности

* **Уровни логирования:** От детальной трассировки (`TRACE`) до критических сбоев (`CRITICAL`).
* **Цветной вывод:** Автоматическая раскраска сообщений в консоли в зависимости от уровня.
* **Файловое логирование:** Поддержка записи логов в файл с ротацией (через Config) и временными метками.
* **Трассировка:** Специальные макросы для отслеживания входа/выхода из функций.
* **Потокобезопасность:** Защита вывода мьютексами.

## Подключение и Инициализация

Для использования логгера в вашем классе или файле используйте один из макросов инициализации.

### 1. Именованный логгер

Создает статический экземпляр логгера с заданным именем модуля (отображается в квадратных скобках `[MODULE]`).

```cpp
#include "logger.hpp"

// В начале файла или класса
LOGGER("MyModule");

void my_function() {
    logger.info("Hello from MyModule!");
}

```

### 2. Автоматический логгер

Создает логгер, используя имя текущего файла (без расширения) в качестве имени модуля.

```cpp
#include "logger.hpp"

// Если файл называется network_manager.cpp, имя модуля будет "network_manager"
LOGGER_AUTO();

```

## Уровни логирования

| Уровень | Enum | Описание | Цвет в консоли |
| --- | --- | --- | --- |
| **TRACE** | `LogLevel::TRACE` | Максимальная детализация (дампы, шаги циклов). | Серый |
| **DEBUG** | `LogLevel::DEBUG` | Отладочная информация (значения переменных). | Голубой |
| **INFO** | `LogLevel::INFO` | Штатная работа (запуск, соединение). | Зеленый |
| **WARNING** | `LogLevel::WARNING` | Предупреждения (некритичные ошибки). | Желтый |
| **ERROR** | `LogLevel::ERROR` | Ошибки операций. | Красный |
| **CRITICAL** | `LogLevel::CRITICAL` | Критические сбои, остановка работы. | Маджента (Жирный) |

## Использование

### Базовый вывод

Синтаксис аналогичен `std::format` или `printf`, но использует фигурные скобки `{}` для подстановки аргументов.

```cpp
std::string user = "Admin";
int port = 8080;

logger.info("User {} connected on port {}", user, port);
logger.error("Failed to bind port {}", port);
logger.debug("Current connections: {}", 5);

```

### Трассировка функций

Для отладки сложных алгоритмов используйте макросы трассировки. Они работают только если глобальный уровень логов установлен в `TRACE`.

```cpp
void process_data(int id) {
    // Логирует: --> process_data(id=42)
    LOG_TRACE_ENTER_ARGS("id=" << id); 

    // Ваш код...
    bool success = true;

    // Логирует: <-- process_data -> true
    LOG_TRACE_EXIT_VALUE(success);
}

void simple_func() {
    LOG_TRACE_ENTER(); // Логирует: --> simple_func
    // ...
    LOG_TRACE_EXIT();  // Логирует: <-- simple_func
}

```

## Управление логированием

### Настройка вывода в файл

Обычно управляется через класс `Config`, но может быть вызвана вручную:

```cpp
// Включение записи в файл
Logger::enable_file_logging("logs/server.log");

// Отключение
Logger::disable_file_logging();

```

### Изменение уровня логирования

Глобальный уровень можно изменить во время выполнения:

```cpp
set_log_level(LogLevel::DEBUG);

```