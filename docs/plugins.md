# Структура плагинов GoodNet

## Типы плагинов

В системе существует два типа плагинов:

| Тип          | Назначение                                                                 | C-сигнатура инициализации |
|--------------|---------------------------------------------------------------------------|---------------------------|
| `Handler`    | Обработка сообщений определённых типов и реакция на события соединений    | `handler_init_t`          |
| `Connector`  | Реализация сетевых соединений для конкретных протоколов (TCP, UDP и др.)  | `connector_init_t`        |

## Общая структура

Все плагины:
- Загружаются динамически как shared objects (.so)
- Имеют точку входа для инициализации (`handler_init` или `connector_init`)
- Получают указатель на `host_api_t` с ограниченным API хоста
- Должны быть скомпилированы с тем же ABI, что и ядро

---

## Handler Plugin (Обработчик)

### Назначение
Обработка сообщений определённых типов и управление состоянием соединений.

### Ключевые параметры:
```c
handler_t {
    void (*handle_message)(...)     // Обработка входящих сообщений
    void (*handle_conn_state)(...)  // Обработка изменений состояния соединений
    uint32_t* supported_types       // Массив поддерживаемых типов сообщений
    size_t num_supported_types      // Количество поддерживаемых типов
    void* user_data                 // Контекст плагина
}
```

### Как работает:
1. Регистрирует типы сообщений через `supported_types`
2. Получает сообщения только указанных типов через `handle_message`
3. Получает уведомления об изменениях состояния соединений через `handle_conn_state`
4. Может отправлять сообщения через `host_api_t::send`

---

## Connector Plugin (Коннектор)

### Назначение
Реализация сетевого взаимодействия для конкретного транспорта.

### Ключевые компоненты:

**1. Уровень коннектора (`connector_ops_t`):**
```c
connector_ops_t {
    connection_ops_t* (*connect)(...)    // Создание исходящего соединения
    int (*listen)(...)                   // Запуск прослушивания порта
    void (*get_scheme)(...)              // Получение схемы URI (tcp, udp)
    void (*get_name)(...)                // Человекочитаемое имя
    void (*shutdown)(...)                // Корректное завершение работы
    void* connector_ctx                  // Контекст коннектора
}
```

**2. Уровень соединения (`connection_ops_t`):**
```c
connection_ops_t {
    int (*send)(...)                      // Отправка данных
    int (*close)(...)                     // Закрытие соединения
    int (*is_active)(...)                 // Проверка активности
    void (*get_endpoint)(...)             // Получение удалённого эндпоинта
    void (*get_uri)(...)                  // Получение URI соединения
    void (*set_callbacks)(...)            // Установка колбэков
    void* conn_ctx                        // Контекст соединения
}
```

### Как работает:
1. Регистрирует схему транспорта (например, "tcp")
2. Создаёт соединения по запросу ядра
3. Передаёт входящие данные ядру через колбэки
4. Управляет состоянием соединений

---

## C++ Обёртки SDK

Для упрощения разработки на C++ предоставляются классы-обёртки:

### Для обработчиков:
```cpp
class gn::IHandler {
public:
    virtual void handle_message(...) = 0;       // Чистый виртуальный метод
    virtual void handle_connection_state(...);  // Опциональный метод
    void set_supported_types(...);               // Установка типов сообщений
protected:
    void log(...);                               // Безопасный логгинг
    void send(...);                              // Отправка сообщений
};
```
**Преимущества:**
- Автоматическая конвертация в C-интерфейс через `to_c_handler()`
- Типобезопасная работа с данными
- Упрощённое управление контекстом

### Для коннекторов:
```cpp
class gn::IConnector {
public:
    virtual std::unique_ptr<IConnection> create_connection(...) = 0;
    virtual bool start_listening(...) = 0;
    virtual std::string get_scheme() const = 0;
protected:
    void log(...);  // Безопасный логгинг
};

class gn::IConnection {
public:
    virtual bool do_send(...) = 0;               // Отправка данных
    virtual void do_close() = 0;                 // Закрытие соединения
    virtual endpoint_t get_remote_endpoint() = 0; // Получение эндпоинта
protected:
    void notify_data(...);  // Уведомление о входящих данных
    void notify_close();    // Уведомление о закрытии
};
```
**Преимущества:**
- RAII-управление ресурсами
- ООП-интерфейс вместо работы с указателями
- Автоматическая регистрация колбэков

---

## Регистрация плагина

Для интеграции с ядром необходимо экспортировать функцию инициализации:

**Для C:**
```c
extern "C" int handler_init(host_api_t* api, handler_t** handler);
extern "C" int connector_init(host_api_t* api, connector_ops_t** ops);
```

**Для C++ (через макросы SDK):**
```cpp
// Для обработчика
HANDLER_PLUGIN(ClassName); 

// Для коннектора
CONNECTOR_PLUGIN(ClassName);
```
Эти макросы автоматически:
1. Создают статический экземпляр класса
2. Проверяют тип плагина
3. Инициализируют контекст
4. Экспортируют правильные символы

---

## Требования к реализации

1. **Для обработчиков:**
   - Обязательно реализовать `handle_message`
   - Указать поддерживаемые типы сообщений
   - Корректно обрабатывать пустые payload

2. **Для коннекторов:**
   - Реализовать минимальный набор методов:
     - `create_connection` или `start_listening`
     - `get_scheme`
     - `get_name`
   - Обеспечить потокобезопасность соединений
   - Корректно закрывать все ресурсы в `shutdown`

3. **Общие требования:**
   - Не использовать глобальные переменные
   - Не создавать свои потоки
   - Обрабатывать ошибки и не падать при некорректных входных данных
   - Освобождать все ресурсы при завершении работы